on: [push]

name: jdk8s-full-cicd

env:
  resourceGroup: jdk8s
  location: eastus
  SESSION_TRACKING: jdk8s
  USER_ID: jessde
  subName: "ca-jessde-demo-test"
  aksName: jdk8s
  vnetName: jdk8sVnet
  subnetName: jdk8sSubnet
  vnodeSubnetName: VNSubnet

  # Deployment Paths
  Infrastructure: IaC/deployment.json
  # tailwindCharts: TailwindTraders-Backend/Deploy/helm
  # tailwindChartValuesScript: helm-values/generate-config.ps1
  # tailwindChartValues: values.yaml
  # tailwindWebImages: TailwindTraders-Backend/Deploy/tailwindtraders-images
  # tailwindServiceAccount: TailwindTraders-Backend/Deploy/helm/ttsa.yaml
  # # Github SECRETS
  # sqlServerUser: sqladmin

jobs:
  deployInfra:
    runs-on: self-hosted
    steps:
      # checkout branch
      - name: git checkout master branch
        uses: actions/checkout@master

      # log into Azure
      - name: "Login via Azure CLI"
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # create resource group
      - name: "Create Resource Group"
        run: |
          az group create --subscription "$subName" --name $resourceGroup --location $location --tags Tracking=$SESSION_TRACKING CreatedBy=$USER_ID

      # create VNet
      - name: "Create Virtual Network"
        run: |
          # run check for idempotent pipeline
          vnetCheck=$(az network vnet list -g $resourceGroup -o tsv --query [0].name)
          if [[  $vnetCheck == *$vnetName*  ]]; then
            echo 'Virtual Network already exists'
          else
            echo 'Virtual network does not exist. Creating virtual network now.'
            # create vnet
            az network vnet create --resource-group $resourceGroup --name $vnetName --subscription "$subName" --address-prefixes 10.0.0.0/8 --subnet-name $subnetName --subnet-prefix 10.240.0.0/16
          fi

      # create virtual node subnet
      - name: "Create Virtual Node Subnet"
        run: |
          # run check for idempotent pipeline
          vnetSubnetCheck=$(az network vnet subnet list -g $resourceGroup --vnet-name $vnetName -o tsv --query '[1].name')

          if [[  $vnetSubnetCheck == *$vnodeSubnetName* ]]; then
            echo 'Virtual node subnet already exists'
          else
            echo 'Virtual node subnet does not exist. Creating virtual subnet now.'
            # configure vnet subnet
            az network vnet subnet create --resource-group $resourceGroup --subscription "$subName" --vnet-name $vnetName --name $vnodeSubnetName --address-prefix 10.241.0.0/16
          fi

      #  Deploy backend infrastructure
      - name: "Setup Backend Infra"
        env:
          azureClientID: 47e460d8-c66e-4489-85dd-ee2b522aaea5
        run: |
          vnetID=$(az network vnet subnet show --resource-group $resourceGroup --vnet-name $vnetName --name $subnetName --query id -o tsv)

          az group deployment create -g $resourceGroup --template-file $Infrastructure \
            --parameters servicePrincipalId=$azureClientID servicePrincipalSecret=${{ secrets.CLIENT_SECRET }} \
            aksVersion=1.14.8 vnetSubnetID=$vnetID

          echo "::set-env name=AKS_CLUSTER::$(az aks list --resource-group $resourceGroup --query [0].name -o tsv)"

          AKS_CLUSTER=$(az aks list --resource-group $resourceGroup --query [0].name -o tsv)

          az aks get-credentials --name $AKS_CLUSTER --resource-group $resourceGroup --admin --overwrite-existing

      # Setup virutal node
      - name: "Install Virtual Node on K8s cluster"
        run: |
          vNodeEnabledCheck=$(az aks show --resource-group $resourceGroup --name $AKS_CLUSTER --query addonProfiles.aciConnectorLinux.enabled -o tsv)
          if [[ $vNodeEnabledCheck == *true*  ]]; then
            echo "AKS Virtual Node add-on already enabled."
          else
            # Deploy virtual node
            az aks enable-addons \
            --resource-group $resourceGroup  \
            --name $AKS_CLUSTER \
            --addons virtual-node \
            --subnet-name $vnodeSubnetName
          fi

      # Ngnix for production
      - name: "Configure Ngnix for production"
        env:
          nameSpace: ingress
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Namespace
          metadata:
            name: $nameSpace
          EOF

          helm repo add stable http://storage.googleapis.com/kubernetes-charts

          helm repo update

          helm upgrade --install nginx-ingress stable/nginx-ingress \
          --namespace $nameSpace \
          --set controller.replicaCount=2 \
          --set controller.nodeSelector."beta\.kubernetes\.io/os"=linux \
          --set defaultBackend.nodeSelector."beta\.kubernetes\.io/os"=linux

      - name: "Create cert manager namespace"
        env:
          nameSpace: cert-manager
        run: |
          # cert manager namespace
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Namespace
          metadata:
            name: $nameSpace
          EOF

      - name: "Jetstack Cert Manager Config"
        run: |
          kubectl apply --validate=false \
          -f https://raw.githubusercontent.com/jetstack/cert-manager/release-0.13/deploy/manifests/00-crds.yaml

          helm repo add jetstack https://charts.jetstack.io

          helm upgrade --install cert-mgr --namespace cert-manager jetstack/cert-manager --set ingressShim.defaultIssuerName=letsencrypt-prod --set ingressShim.defaultIssuerKind=ClusterIssuer

          kubectl apply -f IaC/cluster-issuer.yaml

      - name: "Create jfrog-dev namespace/secret"
        env:
          secretName: jdk8s
          nameSpace: jfrog
        run: |
          # jfrog dev namespace
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Namespace
          metadata:
            name: $nameSpace
          ---
          apiVersion: v1
          kind: Secret
          metadata:
            name: $secretName
            namespace: $nameSpace
          type:  kubernetes.io/dockerconfigjson
          data:
            .dockerconfigjson: ${{ secrets.DOCKER_CFG }}
          EOF

      - name: "Create jfrog-prod namespace/secret"
        env:
          secretName: jdk8s
          nameSpace: jfrog-prod
        run: |
          # jfrog prod namespace
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Namespace
          metadata:
            name: $nameSpace
          ---
          apiVersion: v1
          kind: Secret
          metadata:
            name: $secretName
            namespace: $nameSpace
          type:  kubernetes.io/dockerconfigjson
          data:
            .dockerconfigjson: ${{ secrets.DOCKER_CFG }}
          EOF

      - name: "Create keda namespace"
        env:
          nameSpace: keda
        run: |
          # keda namespace
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Namespace
          metadata:
            name: $nameSpace
          EOF

      - name: "Setup scaling backend components"
        run: |
          # add kedacore repo
          helm repo add kedacore https://kedacore.github.io/charts

          # add stable repo for helm 3
          helm repo add stable http://storage.googleapis.com/kubernetes-charts

          # repo update
          helm repo update

          # keda install
          helm upgrade --install keda kedacore/keda --namespace keda

          # rabbitmq install
          helm upgrade --install rabbitmq --set rabbitmq.username=user,rabbitmq.password=PASSWORD stable/rabbitmq

          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: rabbitmq-consumer
          data:
            RabbitMqHost: YW1xcDovL3VzZXI6UEFTU1dPUkRAcmFiYml0bXEuZGVmYXVsdC5zdmMuY2x1c3Rlci5sb2NhbDo1Njcy
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: rabbitmq-consumer
            namespace: default
            labels:
              app: rabbitmq-consumer
          spec:
            selector:
              matchLabels:
                app: rabbitmq-consumer
            template:
              metadata:
                labels:
                  app: rabbitmq-consumer
              spec:
                containers:
                - name: rabbitmq-consumer
                  image: jeffhollan/rabbitmq-client:dev
                  imagePullPolicy: Always
                  command:
                    - receive
                  args:
                    - 'amqp://user:PASSWORD@rabbitmq.default.svc.cluster.local:5672'
                  envFrom:
                  - secretRef:
                      name: rabbitmq-consumer
                dnsPolicy: ClusterFirst
                nodeSelector:
                  kubernetes.io/role: agent
                  beta.kubernetes.io/os: linux
                  type: virtual-kubelet
                tolerations:
                - key: virtual-kubelet.io/provider
                  operator: Exists
                - key: azure.com/aci
                  effect: NoSchedule    
          ---
          apiVersion: keda.k8s.io/v1alpha1
          kind: ScaledObject
          metadata:
            name: rabbitmq-consumer
            annotations:
              "helm.sh/hook": crd-install
            namespace: default
            labels:
              deploymentName: rabbitmq-consumer
          spec:
            scaleTargetRef:
              deploymentName: rabbitmq-consumer
            pollingInterval: 5   # Optional. Default: 30 seconds
            cooldownPeriod: 30   # Optional. Default: 300 seconds
            maxReplicaCount: 30  # Optional. Default: 100
            triggers:
            - type: rabbitmq
              metadata:
                queueName: hello
                host: RabbitMqHost
                queueLength  : '5'
          EOF

      - name: "Notes"
        run: |
          INGRESS=$(az aks show -n $AKS_CLUSTER -g $resourceGroup --query addonProfiles.httpApplicationRouting.config.HTTPApplicationRoutingZoneName -o tsv)
          echo "*************** Connection Information ***************"
          echo "The Tailwind Traders Website can be accessed at:"
          echo "http://{$INGRESS}"
          echo ""
          echo "Run the following to connect to the AKS cluster:"
          echo "az aks get-credentials --name $AKS_CLUSTER --resource-group $resourceGroup --admin"
          echo "******************************************************"
      # - name: "Create k8s service account"
      #   env:
      #     nameSpace: twt
      #   run: |
      #     cat <<EOF | kubectl apply -f -
      #     apiVersion: v1
      #     kind: ServiceAccount
      #     imagePullSecrets:
      #     - name: acr-auth
      #     metadata:
      #       name: ttsa
      #       namespace: $nameSpace
      #     EOF
  buildImages:
    runs-on: self-hosted
    needs: deployInfra
    env:
      artDockerURL: jfrogjd-docker.jfrog.io
      ART_URL: https://jfrogjd.jfrog.io/jfrogjd/
      ART_USER: admin
      SERVER_ID: jfrog-jd
      SLACK_CHANNEL: chattybot
    steps:
      - name: "jfrog install, configure cli"
        run: |
          #Login to Docker with jfrog artifactory creds
          echo ${{ secrets.ART_PASS }} | docker login $artDocker_URL -u $ART_USER --password-stdin && echo "jfrog docker login successful"

          # Get Jfrog CLI
          if [ -e jfrog ]; then
              echo "Jfrog binary already exists. Logging into Artifactory now.."
          else
              echo "Jfrog binary does not exist. Downloading now...."
              wget https:// dl.bintray.com/jfrog/jfrog-cli-go/1.24.2/jfrog-cli-linux-amd64/jfrog
              chmod +x jfrog
          fi

          # Configure Jfrog CLI
          ./jfrog rt config $SERVER_ID --url=$ART_URL --user=$ART_USER --password=${{ secrets.ART_PASS }}
      - name: "jfrog maven build"
        run: |
          # --- jfrog Maven Build
          export M2_HOME=/usr/share/maven
          ./jfrog rt mvn "clean install -Dproject.version=$GITHUB_SHA -Dartifactory.publish.buildInfo=true" maven.yaml --build-name=$GITHUB_WORKFLOW --build-number=$GITHUB_RUN_ID

      # docker login
      - name: "docker login"
        uses: azure/docker-login@v1
        with:
          login-server: $artDockerURL
          username: $ART_USER
          password: ${{ secrets.ART_PASS }}

      # build/push
      - name: "build/push chattybot"
        run: |
          docker build -f Dockerfile . -t $CONTAINER_REGISTRY/chattybot:$GITHUB_SHA
          docker push $CONTAINER_REGISTRY/chattybot:$GITHUB_SHA

      # helm lint
      - name: "helm lint"
        run: |
          helm lint charts/spring-boot-websocket-chat-demo

      - name: "helm package"
        run: |
          helm package charts/spring-boot-websocket-chat-demo

      - name: "publish build info to artifactory"
        run: |
          # --- JFrog Publish Build Info to Artifactory
          #./jfrog rt build-add-dependencies $GITHUB_WORKFLOW $GITHUB_RUN_ID "target/*.jar"
          ./jfrog rt build-collect-env $GITHUB_WORKFLOW $GITHUB_RUN_ID
          ./jfrog rt build-add-git $GITHUB_WORKFLOW $GITHUB_RUN_ID

          # --- Jfrog Docker Push
          ./jfrog rt docker-push --server-id=$SERVER_ID --build-name=$GITHUB_WORKFLOW --build-number=$GITHUB_RUN_ID "$artDocker_URL/$GITHUB_REPOSITORY:$GITHUB_RUN_ID" docker-dev

          # --- Upload Helm Chart Artifact to Artifactory
          ./jfrog rt upload --server-id=$SERVER_ID --build-name=$GITHUB_WORKFLOW --build-number=$GITHUB_RUN_ID "$GITHUB_WORKSPACE/*.tgz" helm-repo
          # -- build publish
          ./jfrog rt build-publish --build-url="https://github.com/$GITHUB_REPOSITORY/runs/$GITHUB_RUN_ID" --env-exclude="*key*;*pass*;" $GITHUB_WORKFLOW $GITHUB_RUN_ID |& tee publish.txt

          # --- Xray Scan
          ./jfrog rt build-scan --server-id=$SERVER_ID $GITHUB_WORKFLOW $GITHUB_RUN_ID | tee results.json

      - name: "slack build trigger"
        run: |
          ## Jfrog Build
          JF_BUILD=$(sed -n "s/^.*http/http/p" publish.txt)

          curl -X POST https://slack.com/api/chat.postMessage -H 'Accept: */*'   -H 'Authorization: Bearer ${{ secrets.slackBotToken }}'   -H 'Connection: keep-alive'   -H 'Content-Type: application/json; charset=utf-8'   -H 'accept-encoding: gzip, deflate'   -d '{"channel": "$SLACK_CHANNEL", "text": "Jfrog Artifactory Build $GITHUB_RUN_ID Information", "attachments": [
                  {
                      "fallback": "JFrog Artifactory Build $GITHUB_RUN_ID Information",
                      "color": "#36a64f",
                      "author_link": "'$JF_BUILD'",
                      "title": "JFrog Build Artifacts",
                      "title_link": "'$JF_BUILD'",
                      "text": "Build Artifacts for $GITHUB_RUN_ID",
                      "fields": [
                          {
                              "title": "Requested for",
                              "value": "Jessica Deen",
                              "short": false
                          }
                      ],
                      "footer": "JFrog Artifactory Notifications",
                      "footer_icon": "https://www.clipartmax.com/png/middle/69-698347_jfrog-artifactory-logo.png"
                  }
              ]
          }' && echo "Slack Build Message Posted"

      - name: "Slack Xray Trigger"
        run: |
          ## Jfrog Xray Scan

          JF_XRAY_ALERTS=$(jq ".summary.total_alerts" results.json)
          JF_SCAN_FAIL=$(jq ".summary.fail_build" results.json)
          JF_XRAY_RPT="https://jfrogjd-xray.jfrog.io/web/#/component/details/docker:~2F~2Fjldeen~2Fspring-boot-websocket-chat-demo/$GITHUB_RUN_ID"

          if [[ $JF_XRAY_ALERTS -eq 0 ]]; then
            slackStyle=good && echo "No Xray Scan alerts found"
          else
            slackStyle=danger && echo "Xray scan alerts found"
          fi

          curl -X POST https://slack.com/api/chat.postMessage -H 'Accept: */*'   -H 'Authorization: Bearer $(slackBotToken)'   -H 'Connection: keep-alive'   -H 'Content-Type: application/json; charset=utf-8'   -H 'accept-encoding: gzip, deflate'   -d '{"channel": "$SLACK_CHANNEL", "text": "JFrog XRay Scan Report for GitHub Run $GITHUB_RUN_ID", "attachments": [
                  {
                      "fallback": "JFrog XRay Scan Report for GitHub Run $GITHUB_RUN_ID",
                      "color": "'$slackStyle'",
                      "author_link": "'$JF_XRAY_RPT'",
                      "title": "JFrog XRay Scan Report",
                      "title_link": "'$JF_XRAY_RPT'",
                      "text": "JFrog Xray Scan Report for GitHub Run $GITHUB_RUN_ID",
                      "fields": [
                          {
                              "title": "XRay Alerts",
                              "value": "'$JF_XRAY_ALERTS' alerts were generated",
                              "short": false
                          },
                          {
                              "title": "Requested for",
                              "value": "Jessica Deen",
                              "short": false
                          }
                      ],
                      "footer": "JFrog XRay Scan Notifications",
                      "footer_icon": "https://www.clipartmax.com/png/middle/69-698347_jfrog-artifactory-logo.png"
                  }
              ]
          }' > /dev/null 2>&1 && echo "Slack XRay Message Posted"
          #if [[ "'$JF_SCAN_FAIL'" = *true* ]]; then exit 1; else exit 0; fi
  # deployMicroservices:
  #   runs-on: self-hosted
  #   needs: buildImages
  #   env:
  #     nameSpace: jfrog
  # steps:
  #     - name: "configure deployment environment"
  #       run: |
  #         # set for this step
  #         AKS_CLUSTER=$(az aks list --resource-group $resourceGroup --query [0].name -o tsv)
  #         # persist env vars
  #         echo "::set-env name=AKS_CLUSTER::$(az aks list --resource-group $resourceGroup --query [0].name -o tsv)"
  #         echo "::set-env name=INGRESS::$(az aks show -n $AKS_CLUSTER -g $resourceGroup --query addonProfiles.httpApplicationRouting.config.HTTPApplicationRoutingZoneName -o tsv)"
  #         # acr/container registry variables
  #         # echo "::set-env name=acrName::$(az acr list -g $resourceGroup -o tsv --query "[0].name")"
  #         echo "::set-env name=CONTAINER_REGISTRY::$(az acr list -g $resourceGroup -o tsv --query [0].loginServer)"
  #         echo "::set-env name=pictures::$(az storage account list -g $resourceGroup --query [0].primaryEndpoints.blob -o tsv)"
  #         # git -C TailwindTraders-Backend checkout ed86d5f
  #     - name: "helm install login api"
  #       run: |
  #         # twt login
  #         helm upgrade --install my-tt-login -f $tailwindChartValues --namespace=$nameSpace --set ingress.hosts={$INGRESS} --set image.repository=$CONTAINER_REGISTRY/login.api --set image.tag=$GITHUB_SHA --set inf.storage.profileimages=${pictures}profiles-list $tailwindCharts/login-api
  #     - name: "helm install product api"
  #       run: |
  #         # twt product
  #         helm upgrade --install my-tt-product -f $tailwindChartValues --namespace=$nameSpace --set ingress.hosts={$INGRESS} --set image.repository=$CONTAINER_REGISTRY/product.api --set image.tag=$GITHUB_SHA --set inf.storage.productimages=${pictures}product-list --set inf.storage.productdetailimages=${pictures}product-detail --set az.productvisitsurl=http://your-product-visits-af-here $tailwindCharts/products-api
  #     - name: "helm install coupon api"
  #       run: |
  #         # twt coupon
  #         helm upgrade --install my-tt-coupon -f $tailwindChartValues --namespace=$nameSpace --set ingress.hosts={$INGRESS} --set image.repository=$CONTAINER_REGISTRY/coupon.api --set image.tag=$GITHUB_SHA --set inf.storage.couponimage=${pictures}coupon-list $tailwindCharts/coupons-api
  #     - name: "helm install profile api"
  #       run: |
  #         # twt profile
  #         helm upgrade --install my-tt-profile -f $tailwindChartValues --namespace=$nameSpace --set ingress.hosts={$INGRESS} --set image.repository=$CONTAINER_REGISTRY/profile.api --set image.tag=$GITHUB_SHA --set inf.storage.profileimages=${pictures}profiles-list $tailwindCharts/profiles-api
  #     - name: "helm install popular product api"
  #       run: |
  #         # twt popular product
  #         helm upgrade --install my-tt-popular-product -f $tailwindChartValues --namespace=$nameSpace --set ingress.hosts={$INGRESS} --set image.repository=$CONTAINER_REGISTRY/popular-product.api --set image.tag=$GITHUB_SHA --set initImage.repository=$CONTAINER_REGISTRY/popular-product-seed.api --set initImage.tag=$GITHUB_SHA --set inf.storage.productimages=${pictures}product-list $tailwindCharts/popular-products-api
  #     - name: "helm install stock api"
  #       run: |
  #         # twt stock
  #         helm upgrade --install my-tt-stock -f $tailwindChartValues --namespace=$nameSpace --set ingress.hosts={$INGRESS} --set image.repository=$CONTAINER_REGISTRY/stock.api --set image.tag=$GITHUB_SHA $tailwindCharts/stock-api
  #     - name: "helm install image classifier api"
  #       run: |
  #         # twt image classifier
  #         helm upgrade --install my-tt-image-classifier -f $tailwindChartValues --namespace=$nameSpace --set ingress.hosts={$INGRESS} --set image.repository=$CONTAINER_REGISTRY/image-classifier.api --set image.tag=$GITHUB_SHA $tailwindCharts/image-classifier-api
  #     - name: "helm install cart api"
  #       run: |
  #         # twt cart
  #         helm upgrade --install my-tt-cart -f $tailwindChartValues --namespace=$nameSpace --set ingress.hosts={$INGRESS} --set image.repository=$CONTAINER_REGISTRY/cart.api --set image.tag=$GITHUB_SHA $tailwindCharts/cart-api --set B2C.clientID=none --set B2C.identityMetadata=none --set B2C.issuer=none --set B2C.policyName=none --set B2C.tenantID=none
  #     - name: "helm install mobile bff api"
  #       run: |
  #         # twt mobile bff
  #         helm upgrade --install my-tt-mobilebff -f $tailwindChartValues --namespace=$nameSpace --set ingress.hosts={$INGRESS} --set image.repository=$CONTAINER_REGISTRY/mobileapigw --set image.tag=$GITHUB_SHA --set probes.readiness=null $tailwindCharts/mobilebff
  #         # helm upgrade --install my-tt-mobilebff -f $tailwindChartValues --namespace=$nameSpace --set ingress.hosts={$INGRESS} --set image.repository=neilpeterson/mobileapigw --set image.tag=v2 --set probes.readiness=null $tailwindCharts/mobilebff
  #     - name: "helm install web bff api"
  #       run: |
  #         # twt web bff
  #         helm upgrade --install my-tt-webbff -f $tailwindChartValues --namespace=$nameSpace --set ingress.hosts={$INGRESS} --set image.repository=$CONTAINER_REGISTRY/webapigw --set image.tag=$GITHUB_SHA $tailwindCharts/webbff --set B2C.Authority=none --set B2C.B2CIssuer=none
  #         # helm upgrade --install my-tt-webbff -f $tailwindChartValues --namespace=$nameSpace --set ingress.hosts={$INGRESS} --set image.repository=neilpeterson/webapigw --set image.tag=v2 $tailwindCharts/webbff --set B2C.Authority=none --set B2C.B2CIssuer=none
  #     - name: "helm install web frontend"
  #       run: |
  #         # twt web
  #         helm upgrade --install web -f TailwindTraders-Website/Deploy/helm/gvalues.yaml --namespace=$nameSpace --set ingress.protocol=http --set ingress.hosts={$INGRESS} --set image.repository=$CONTAINER_REGISTRY/web --set image.tag=$GITHUB_SHA TailwindTraders-Website/Deploy/helm/web/
  #     - name: "Label all pods for network policy"
  #       run: |
  #         # add label
  #         kubectl label -n twt pods --all role=twt-app --overwrite=true
  #     - name: "Copy website images to storage"
  #       run: |
  #         STORAGE=$(az storage account list -g $resourceGroup -o table --query  [].name -o tsv)
  #         BLOB_ENDPOINT=$(az storage account list -g $resourceGroup --query [].primaryEndpoints.blob -o tsv)
  #         CONNECTION_STRING=$(az storage account show-connection-string -n $STORAGE -g $resourceGroup -o tsv)
  #         az storage container create --name "coupon-list" --public-access blob --connection-string $CONNECTION_STRING
  #         az storage container create --name "product-detail" --public-access blob --connection-string $CONNECTION_STRING
  #         az storage container create --name "product-list" --public-access blob --connection-string $CONNECTION_STRING
  #         az storage container create --name "profiles-list" --public-access blob --connection-string $CONNECTION_STRING
  #         az storage blob upload-batch --destination $BLOB_ENDPOINT --destination coupon-list  --source $tailwindWebImages/coupon-list --account-name $STORAGE
  #         az storage blob upload-batch --destination $BLOB_ENDPOINT --destination product-detail --source $tailwindWebImages/product-detail --account-name $STORAGE
  #         az storage blob upload-batch --destination $BLOB_ENDPOINT --destination product-list --source $tailwindWebImages/product-list --account-name $STORAGE
  #         az storage blob upload-batch --destination $BLOB_ENDPOINT --destination profiles-list --source $tailwindWebImages/profiles-list --account-name $STORAGE
  #     - name: "Setup scaling backend components"
  #       run: |
  #         # add kedacore repo
  #         helm repo add kedacore https://kedacore.github.io/charts
  #         # add stable repo for helm 3
  #         helm repo add stable http://storage.googleapis.com/kubernetes-charts
  #         # repo update
  #         helm repo update
  #         # keda install
  #         helm upgrade --install keda kedacore/keda --namespace keda
  #         # rabbitmq install
  #         helm upgrade --install rabbitmq --set rabbitmq.username=user,rabbitmq.password=PASSWORD stable/rabbitmq
  #         cat <<EOF | kubectl apply -f -
  #         apiVersion: v1
  #         kind: Secret
  #         metadata:
  #           name: rabbitmq-consumer
  #         data:
  #           RabbitMqHost: YW1xcDovL3VzZXI6UEFTU1dPUkRAcmFiYml0bXEuZGVmYXVsdC5zdmMuY2x1c3Rlci5sb2NhbDo1Njcy
  #         ---
  #         apiVersion: apps/v1
  #         kind: Deployment
  #         metadata:
  #           name: rabbitmq-consumer
  #           namespace: default
  #           labels:
  #             app: rabbitmq-consumer
  #         spec:
  #           selector:
  #             matchLabels:
  #               app: rabbitmq-consumer
  #           template:
  #             metadata:
  #               labels:
  #                 app: rabbitmq-consumer
  #             spec:
  #               containers:
  #               - name: rabbitmq-consumer
  #                 image: jeffhollan/rabbitmq-client:dev
  #                 imagePullPolicy: Always
  #                 command:
  #                   - receive
  #                 args:
  #                   - 'amqp://user:PASSWORD@rabbitmq.default.svc.cluster.local:5672'
  #                 envFrom:
  #                 - secretRef:
  #                     name: rabbitmq-consumer
  #               dnsPolicy: ClusterFirst
  #               nodeSelector:
  #                 kubernetes.io/role: agent
  #                 beta.kubernetes.io/os: linux
  #                 type: virtual-kubelet
  #               tolerations:
  #               - key: virtual-kubelet.io/provider
  #                 operator: Exists
  #               - key: azure.com/aci
  #                 effect: NoSchedule
  #         ---
  #         apiVersion: keda.k8s.io/v1alpha1
  #         kind: ScaledObject
  #         metadata:
  #           name: rabbitmq-consumer
  #           annotations:
  #             "helm.sh/hook": crd-install
  #           namespace: default
  #           labels:
  #             deploymentName: rabbitmq-consumer
  #         spec:
  #           scaleTargetRef:
  #             deploymentName: rabbitmq-consumer
  #           pollingInterval: 5   # Optional. Default: 30 seconds
  #           cooldownPeriod: 30   # Optional. Default: 300 seconds
  #           maxReplicaCount: 30  # Optional. Default: 100
  #           triggers:
  #           - type: rabbitmq
  #             metadata:
  #               queueName: hello
  #               host: RabbitMqHost
  #               queueLength  : '5'
  #         EOF
  #     - name: "Notes"
  #       run: |
  #         INGRESS=$(az aks show -n $AKS_CLUSTER -g $resourceGroup --query addonProfiles.httpApplicationRouting.config.HTTPApplicationRoutingZoneName -o tsv)
  #         echo "*************** Connection Information ***************"
  #         echo "The Tailwind Traders Website can be accessed at:"
  #         echo "http://{$INGRESS}"
  #         echo ""
  #         echo "Run the following to connect to the AKS cluster:"
  #         echo "az aks get-credentials --name $AKS_CLUSTER --resource-group $resourceGroup --admin"
  #         echo "******************************************************"
  #     # logout
  #     - name: "Azure logout"
  #       run: |
  #         az logout
